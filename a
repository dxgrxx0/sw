[1mdiff --git a/.editorconfig b/.editorconfig[m
[1mnew file mode 100644[m
[1mindex 0000000..427407b[m
[1m--- /dev/null[m
[1m+++ b/.editorconfig[m
[36m@@ -0,0 +1,4 @@[m
[32m+[m[32mroot = true[m
[32m+[m
[32m+[m[32m[*][m
[32m+[m[32mcharset = utf-8[m
\ No newline at end of file[m
[1mdiff --git a/BaseSkill.h b/BaseSkill.h[m
[1mnew file mode 100644[m
[1mindex 0000000..8a65f5f[m
[1m--- /dev/null[m
[1m+++ b/BaseSkill.h[m
[36m@@ -0,0 +1,47 @@[m
[32m+[m[32m#ifndef BASESKILL_H[m
[32m+[m[32m#define BASESKILL_H[m
[32m+[m
[32m+[m[32m#include <SFML/Window/Keyboard.hpp>[m
[32m+[m[32m#include <SFML/System/Clock.hpp>[m
[32m+[m[32m#include <string>[m
[32m+[m[32m#include <iostream>[m
[32m+[m[32mclass BaseSkill {[m
[32m+[m[32mprotected:[m
[32m+[m[32m    std::string name;           // ìŠ¤í‚¬ ì´ë¦„[m
[32m+[m[32m    sf::Keyboard::Key key;      // ìŠ¤í‚¬ í™œì„±í™” í‚¤[m
[32m+[m[32m    float cooldown;             // ì¿¨íƒ€ì„[m
[32m+[m[32m    sf::Clock cooldownTimer;    // ì¿¨íƒ€ì„ íƒ€ì´ë¨¸[m
[32m+[m[32m    bool isActive;              // í™œì„±í™” ì—¬ë¶€[m
[32m+[m
[32m+[m[32mpublic:[m
[32m+[m[32m    BaseSkill(const std::string& name, sf::Keyboard::Key key, float cooldown)[m
[32m+[m[32m        : name(name), key(key), cooldown(cooldown), isActive(false) {}[m
[32m+[m
[32m+[m[32m    virtual ~BaseSkill() {}[m
[32m+[m
[32m+[m[32m    bool canActivate() const {[m
[32m+[m[32m        return cooldownTimer.getElapsedTime().asSeconds() >= cooldown;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    virtual void activate() {[m
[32m+[m[32m        if (canActivate()) {[m
[32m+[m[32m            isActive = true;[m
[32m+[m[32m            cooldownTimer.restart();[m
[32m+[m[32m            applyEffect(); // ìŠ¤í‚¬ íš¨ê³¼ ì ìš©[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    virtual void update(float deltaTime) {[m
[32m+[m[32m        if (isActive) {[m
[32m+[m[32m            isActive = false; // ìŠ¤í‚¬ì˜ ì§€ì† ì‹œê°„ì´ ëë‚¬ë‹¤ê³  ê°€ì •[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    float getRemainCool() {[m
[32m+[m[32m        return (cooldown - cooldownTimer.getElapsedTime().asSeconds())<0?0: cooldown - cooldownTimer.getElapsedTime().asSeconds();[m
[32m+[m[32m    }[m
[32m+[m[32m    virtual void applyEffect() = 0; // ê° ìŠ¤í‚¬ íš¨ê³¼ êµ¬í˜„[m
[32m+[m
[32m+[m[32m    sf::Keyboard::Key getKey() const { return key; }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m#endif // BASESKILL_H[m
[1mdiff --git a/BladeWhirl.h b/BladeWhirl.h[m
[1mnew file mode 100644[m
[1mindex 0000000..0b04c46[m
[1m--- /dev/null[m
[1m+++ b/BladeWhirl.h[m
[36m@@ -0,0 +1,28 @@[m
[32m+[m[32m#ifndef BLADEWHIRL_H[m
[32m+[m[32m#define BLADEWHIRL_H[m
[32m+[m
[32m+[m[32m#include "BaseSkill.h"[m
[32m+[m[32m#include "Character.h"[m
[32m+[m[32m#include "Monster.h"[m
[32m+[m[32m#include "Utility.h"[m
[32m+[m[32mclass BladeWhirl : public BaseSkill {[m
[32m+[m[32mprivate:[m
[32m+[m[32m    Character* character;[m
[32m+[m	[32mstd::vector<std::unique_ptr<Monster>>& monsters;[m
[32m+[m[32m    float range;[m
[32m+[m[32m    float damage;[m
[32m+[m
[32m+[m[32mpublic:[m
[32m+[m[32m    BladeWhirl(Character* character,std::vector<std::unique_ptr<Monster>>& monsters)[m
[32m+[m[32m        : BaseSkill("Blade Whirl", sf::Keyboard::Q, 2.0f), character(character),monsters(monsters),range(200),damage(100) {}[m
[32m+[m
[32m+[m[32m    void applyEffect() override {[m
[32m+[m[32m        for (auto& monster : monsters) {[m
[32m+[m			[32mif (range >= calculateDistance(character->getPosition(), monster->getPosition())) {[m
[32m+[m				[32mmonster->takeDamage(damage);[m
[32m+[m			[32m}[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m};[m
[32m+[m
[32m+[m[32m#endif // BLADEWHIRL_H[m
[1mdiff --git a/Character.cpp b/Character.cpp[m
[1mindex e0bec8f..0adf239 100644[m
[1m--- a/Character.cpp[m
[1m+++ b/Character.cpp[m
[36m@@ -6,7 +6,7 @@[m
 Character::Character(const std::string& textureFile, float x, float y, float scale, float speed)[m
     : movementSpeed(speed), animationSpeed(0.1f), timeSinceLastFrame(0.0f),[m
 [m
[31m-    currentFrameIndex(0), isSwinging(false), frameWidth(32), frameHeight(32), totalFrames(5),attackRange(200),attackDamage(30),attackApplied(true),facingDirection(90.0f){[m
[32m+[m[32m    currentFrameIndex(0), isSwinging(false), frameWidth(96), frameHeight(97), totalFrames(5),attackRange(200),attackDamage(50),attackApplied(true),facingDirection(90.0f),attackCoolDown(1.0f),health(100),maxHealth(100),defense(0){[m
 [m
     if (!texture.loadFromFile(textureFile)) {[m
         std::cerr << "Failed to load texture" << std::endl;[m
[36m@@ -31,7 +31,7 @@[m [mCharacter::Character(const std::string& textureFile, float x, float y, float sca[m
 void Character::handleInput(float deltaTime) {[m
     // ë°©í–¥ ì…ë ¥ ì²˜ë¦¬[m
     if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up)) {[m
[31m-        if (!isSwinging) { currentFrame.top = 32; facingDirection = 270.0f; } // ë¶ìª½[m
[32m+[m[32m        if (!isSwinging) { currentFrame.top = 97; facingDirection = 270.0f; } // ë¶ìª½[m
         sprite.move(0, -movementSpeed * deltaTime);[m
 [m
     }[m
[36m@@ -41,12 +41,12 @@[m [mvoid Character::handleInput(float deltaTime) {[m
 [m
     }[m
     if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left)) {[m
[31m-        if (!isSwinging) { currentFrame.top = 64; facingDirection = 180.0f; } // ì„œìª½[m
[32m+[m[32m        if (!isSwinging) { currentFrame.top = 291; facingDirection = 180.0f; } // ì„œìª½[m
         sprite.move(-movementSpeed * deltaTime, 0);[m
 [m
     }[m
     if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right)) {[m
[31m-        if (!isSwinging) { currentFrame.top = 96; facingDirection = 0.0f; } // ë™ìª½[m
[32m+[m[32m        if (!isSwinging) { currentFrame.top = 194; facingDirection = 0.0f; } // ë™ìª½[m
         sprite.move(movementSpeed * deltaTime, 0);[m
     }[m
 [m
[36m@@ -57,10 +57,6 @@[m [mvoid Character::handleInput(float deltaTime) {[m
         // ìŠ¬ë˜ì‹œì˜ ìœ„ì¹˜ ì„¤ì •[m
 [m
     }[m
[31m-    else if (sf::Keyboard::isKeyPressed(sf::Keyboard::T)) {[m
[31m-        sprite.setPosition(700, 700);[m
[31m-    }[m
[31m-[m
 }[m
 [m
 void Character::updateAnimation(float deltaTime) {[m
[36m@@ -75,7 +71,7 @@[m [mvoid Character::updateAnimation(float deltaTime) {[m
             if (currentFrameIndex >= totalFrames - 1) {[m
                 currentFrameIndex = 0;[m
                 isSwinging = false;[m
[31m-                currentFrame.top -= 128; // ë‹¤ìŒ ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ìœ¼ë¡œ ì´ë™[m
[32m+[m[32m                currentFrame.top -= 388; // ë‹¤ìŒ ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ìœ¼ë¡œ ì´ë™[m
                 animationSpeed = 0.1f;[m
             }[m
             // ìŠ¬ë˜ì‹œ ìŠ¤í”„ë¼ì´íŠ¸ ìœ„ì¹˜ëŠ” ìŠ¤ìœ™ ì‹œ ê³ ì •[m
[36m@@ -110,7 +106,7 @@[m [msf::Vector2f Character::getPosition() {[m
 }[m
 [m
 void Character::startSwinging() {[m
[31m-    currentFrame.top += 128;[m
[32m+[m[32m    currentFrame.top += 388;[m
     isSwinging = true;[m
     currentFrameIndex = 0;[m
 }[m
[36m@@ -135,6 +131,9 @@[m [mfloat Character::getHealth() {[m
 float Character::getMaxHealth() {[m
     return maxHealth;[m
 }[m
[32m+[m[32mvoid Character::setPosition(sf::Vector2f pos) {[m
[32m+[m[32m    sprite.setPosition(pos);[m
[32m+[m[32m}[m
 [m
 void Character::basicAttack(std::vector<std::unique_ptr<Monster>>& monsters) {[m
     float attackRange = this->getAttackRange();[m
[36m@@ -159,7 +158,7 @@[m [mbool Character::isMonsterInAttackRange(const sf::Vector2f& characterPosition, co[m
 [m
     // ê±°ë¦¬ ê³„ì‚°[m
     float distance = std::sqrt(direction.x * direction.x + direction.y * direction.y);[m
[31m-    if (distance < 40)return true;[m
[32m+[m[32m    if (distance <= 50)return true;[m
     // ê±°ë¦¬ê°€ ê³µê²© ë²”ìœ„ ì´ë‚´ì¸ì§€ ì²´í¬[m
     if (distance > attackRange) {[m
         return false; // ê³µê²© ë²”ìœ„ë¥¼ ì´ˆê³¼í•¨[m
[36m@@ -178,4 +177,33 @@[m [mvoid Character::takeDamage(float damageAmount) {[m
     if (health < 0) {[m
         health = 0;  // ì²´ë ¥ì€ 0 ì´í•˜ë¡œ ë‚´ë ¤ê°€ì§€ ì•ŠìŒ[m
     }[m
[32m+[m[32m}[m
[32m+[m[32mvoid Character::increaseAttackPower(float power) {[m
[32m+[m[32m    attackDamage += power;[m
[32m+[m[32m}[m
[32m+[m[32mvoid Character::increaseMaxHealth(float hp) {[m
[32m+[m[32m    maxHealth += hp;[m
[32m+[m[32m}[m
[32m+[m[32mvoid Character::reduceCooldown(float cooldown) {[m
[32m+[m[32m    attackCoolDown -= cooldown;[m
[32m+[m[32m}[m
[32m+[m[32mvoid Character::increaseSpeed(float speed) {[m
[32m+[m[32m    movementSpeed += speed;[m
[32m+[m[32m}[m
[32m+[m[32mvoid Character::increaseAttackRange(float range) {[m
[32m+[m[32m    attackRange += range;[m
[32m+[m[32m}[m
[32m+[m[32m/*void Character::addSkill(std::unique_ptr<BaseSkill> skill) {[m
[32m+[m[32m    skillManager.addSkill(std::move(skill));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid Character::activateSkill(sf::Keyboard::Key key) {[m
[32m+[m[32m    skillManager.activateSkill(key);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid Character::updateSkills(float deltaTime) {[m
[32m+[m[32m    skillManager.updateSkills(deltaTime);[m
[32m+[m[32m}*/[m
[32m+[m[32mvoid Character::setScale(float scale) {[m
[32m+[m[32m    sprite.setScale(scale,scale);[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/Character.h b/Character.h[m
[1mindex eb891e4..81d9a27 100644[m
[1m--- a/Character.h[m
[1m+++ b/Character.h[m
[36m@@ -3,6 +3,7 @@[m
 #include <string>[m
 #include "Monster.h"[m
 #include "Utility.h"[m
[32m+[m[32m//#include "SkillManager.h"[m
 class Character {[m
 public:[m
     Character(const std::string& textureFile, float x, float y, float scale, float speed);[m
[36m@@ -24,6 +25,16 @@[m [mpublic:[m
     void heal(float healAmount);[m
     bool isMonsterInAttackRange(const sf::Vector2f& characterPosition, const sf::Vector2f& monsterPosition,[m
         float attackRange, float attackAngle, float characterRotation);[m
[32m+[m[32m    void increaseAttackPower(float power);[m
[32m+[m[32m    void increaseMaxHealth(float hp);[m
[32m+[m[32m    void reduceCooldown(float cooldown);[m
[32m+[m	[32mvoid increaseSpeed(float speed);[m
[32m+[m[32m    void increaseAttackRange(float range);[m
[32m+[m[32m    /*void addSkill(std::unique_ptr<BaseSkill> skill);[m
[32m+[m[32m    void activateSkill(sf::Keyboard::Key key);[m
[32m+[m[32m    void updateSkills(float deltaTime);*/[m
[32m+[m[32m    void setPosition(sf::Vector2f pos);[m
[32m+[m[32m    void setScale(float scale);[m
 private:[m
     sf::Sprite sprite;[m
     sf::Texture texture;[m
[36m@@ -47,4 +58,5 @@[m [mprivate:[m
     float defense;[m
     float maxHealth;    //ìµœëŒ€ì²´ë ¥[m
     float health;//í˜„ì¬ì²´ë ¥[m
[31m-};[m
\ No newline at end of file[m
[32m+[m[32m    //SkillManager skillManager;[m
[32m+[m[32m};[m
[1mdiff --git a/Game.cpp b/Game.cpp[m
[1mindex 508a624..1fd544a 100644[m
[1m--- a/Game.cpp[m
[1m+++ b/Game.cpp[m
[36m@@ -1,10 +1,13 @@[m
 #include "Game.h"[m
[32m+[m[32m#include "BladeWhirl.h"[m
[32m+[m[32m#include "BulkUp.h"[m
[32m+[m[32m#include "Teleport.h"[m
 #include <cstdlib>[m
 #include <ctime>[m
[31m-[m
[32m+[m[32m#include <iostream>[m
 Game::Game() :[m
     window(sf::VideoMode(1600, 1000), "Warrior and Monsters"),[m
[31m-    warrior("knightbg.png", 700, 700, 3.0f, 200.0f),[m
[32m+[m[32m    warrior("knight.png", 700, 700, 1.0f, 100.0f),[m
     uiManager(font, &warrior, window),[m
     minimap(600, 600, 0.4f),[m
     mainView(sf::FloatRect(0, 0, 1600, 1000)),[m
[36m@@ -15,7 +18,9 @@[m [mGame::Game() :[m
     experience(0),[m
     level(1),[m
     experienceToNextLevel(100),[m
[31m-    waveManager(&warrior, &mainTower, &monsters, 1600, 1000)[m
[32m+[m[32m    waveManager(&warrior, &mainTower, &monsters, 1600, 1000),[m
[32m+[m[32m    upgradeManager(&warrior, &mainTower),[m
[32m+[m[32m    upgradeUI(font, sf::Vector2f(window.getSize()))[m
 {[m
     minimap.setPosition(3, 3);  // ê¸°ë³¸ ë¯¸ë‹ˆë§µ ìœ„ì¹˜ ì„¤ì •[m
     font.loadFromFile("arial.ttf");[m
[36m@@ -38,34 +43,53 @@[m [mvoid Game::handleEvents() {[m
 }[m
 [m
 void Game::update() {[m
[31m-    float deltaTime = clock.restart().asSeconds();[m
[32m+[m[32m    if (upgradeUI.getIsVisible()) {[m
[32m+[m[32m        sf::Vector2f mousePos = window.mapPixelToCoords(sf::Mouse::getPosition(window));[m
[32m+[m[32m        if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {[m
[32m+[m[32m            int choice = upgradeUI.handleClick(mousePos);[m
[32m+[m[32m            if (choice != -1) {[m
[32m+[m[32m                upgradeManager.applyUpgrade(choice); // ì„ íƒëœ ì—…ê·¸ë ˆì´ë“œ ì ìš©[m
[32m+[m[32m                upgradeUI.hide(); // UI ìˆ¨ê¸°ê¸° (ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ)[m
[32m+[m[32m                clock.restart();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        return; // ì—…ê·¸ë ˆì´ë“œ UIê°€ í™œì„±í™”ëœ ë™ì•ˆ ë‹¤ë¥¸ ê²Œì„ ì—…ë°ì´íŠ¸ ì¤‘ë‹¨[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    deltaTime = clock.restart().asSeconds();[m
     /*if (spawnClock.getElapsedTime().asSeconds() > spawnInterval) {[m
         spawnMonster();[m
         spawnClock.restart();[m
     }*/[m
     warrior.handleInput(deltaTime);[m
[32m+[m[32m    if (sf::Keyboard::isKeyPressed(sf::Keyboard::Q)) {[m
[32m+[m[32m        skillManager.activateSkill(sf::Keyboard::Q); // QìŠ¤í‚¬ í™œì„±í™”[m
[32m+[m[32m    }[m
[32m+[m[32m    if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) {[m
[32m+[m[32m        skillManager.activateSkill(sf::Keyboard::W); // WìŠ¤í‚¬ í™œì„±í™”[m
[32m+[m[32m    }[m
[32m+[m[32m    if (sf::Keyboard::isKeyPressed(sf::Keyboard::E)) {[m
[32m+[m[32m        skillManager.activateSkill(sf::Keyboard::E); // EìŠ¤í‚¬ í™œì„±í™”[m
[32m+[m[32m    }[m
     warrior.updateAnimation(deltaTime);[m
 [m
 [m
     if (warrior.getIsSwinging() && !warrior.getAttackApplied()) {[m
         warrior.basicAttack(monsters);[m
 [m
[31m-        // ì²´ë ¥ì´ 0 ì´í•˜ì¸ ëª¬ìŠ¤í„°ë“¤ì„ í•œ ë²ˆì— ì œê±°[m
[31m-        monsters.erase(std::remove_if(monsters.begin(), monsters.end(),[m
[31m-            [this](const std::unique_ptr<Monster>& monster) {[m
[31m-                if (monster->getHealthPoint() <= 0) {[m
[31m-                    addExp(10);[m
[31m-                }[m
[31m-                return monster->getHealthPoint() <= 0;[m
[31m-            }),[m
[31m-            monsters.end());[m
[31m-[m
         warrior.setAttackApplied(true);  // ê³µê²© ì ìš© ì™„ë£Œ í”Œë˜ê·¸ ì„¤ì •[m
     }[m
[32m+[m[32m    // ì²´ë ¥ì´ 0 ì´í•˜ì¸ ëª¬ìŠ¤í„°ë“¤ì„ í•œ ë²ˆì— ì œê±°[m
[32m+[m[32m    monsters.erase(std::remove_if(monsters.begin(), monsters.end(),[m
[32m+[m[32m        [this](const std::unique_ptr<Monster>& monster) {[m
[32m+[m[32m            if (monster->getHealthPoint() <= 0) {[m
[32m+[m[32m                addExp(100);[m
[32m+[m[32m            }[m
[32m+[m[32m            return monster->getHealthPoint() <= 0;[m
[32m+[m[32m        }),[m
[32m+[m[32m        monsters.end());[m
     if (experience > experienceToNextLevel) {[m
[31m-        experience -= experienceToNextLevel;[m
[31m-        experienceToNextLevel *= 1.5f;[m
[31m-        level += 1;[m
[32m+[m[32m        onLevelUp();[m
     }[m
 [m
     sf::Vector2f warriorPosition = warrior.getPosition();[m
[36m@@ -84,25 +108,31 @@[m [mvoid Game::update() {[m
     uiManager.updateTimer(deltaTime);[m
     uiManager.updateTowerDurability(mainTower.getHealth(), mainTower.getMaxHealth());[m
     mainTower.healNearbyCharacter(deltaTime, warrior);[m
[32m+[m[32m    skillManager.updateSkills(deltaTime);[m
[32m+[m
 }[m
 [m
 void Game::render() {[m
     window.clear();[m
[31m-    window.setView(mainView);[m
[31m-    window.draw(towerSprite);[m
[32m+[m[32m    if (upgradeUI.getIsVisible()) {[m
[32m+[m[32m        window.setView(window.getDefaultView());  // ê¸°ë³¸ ë·°ë¡œ ë³€ê²½[m
[32m+[m[32m        upgradeUI.draw(window); // UIê°€ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ ê·¸ë¦¬ê¸°[m
[32m+[m[32m    }[m
[32m+[m[32m    else {[m
[32m+[m[32m        window.setView(mainView);[m
[32m+[m[32m        window.draw(towerSprite);[m
 [m
[31m-    mainTower.draw(window);[m
[32m+[m[32m        mainTower.draw(window);[m
 [m
[31m-    /*for (auto& monster : monsters) {[m
[31m-        monster.draw(window);[m
[31m-    }*/[m
[32m+[m[32m        waveManager.drawMonsters(window);[m
[32m+[m[32m        warrior.draw(window);[m
 [m
[31m-    waveManager.drawMonsters(window);[m
[31m-    warrior.draw(window);[m
[32m+[m[32m        // ë¯¸ë‹ˆë§µ ê·¸ë¦¬ê¸°[m
[32m+[m[32m        minimap.draw(window);[m
[32m+[m[32m        uiManager.draw(window);// UI ê·¸ë¦¬ê¸°[m
[32m+[m[32m        uiManager.updateSkillCoolTime(skillManager);[m
[32m+[m[32m    }[m
 [m
[31m-    // ë¯¸ë‹ˆë§µ ê·¸ë¦¬ê¸°[m
[31m-    minimap.draw(window);[m
[31m-    uiManager.draw(window);// UI ê·¸ë¦¬ê¸°[m
     window.display();[m
 }[m
 /*[m
[36m@@ -113,4 +143,24 @@[m [mvoid Game::spawnMonster() {[m
 }*/[m
 void Game::addExp(float exp) {[m
     experience += exp;[m
[32m+[m[32m}[m
[32m+[m[32mvoid Game::onLevelUp() {[m
[32m+[m[32m    experience -= experienceToNextLevel;[m
[32m+[m[32m    experienceToNextLevel *= 1.5f;[m
[32m+[m[32m    level += 1;[m
[32m+[m[32m    if (level == 2) {[m
[32m+[m[32m        skillManager.unlockSkill("BladeWhirl");[m
[32m+[m[32m        skillManager.addSkill("BladeWhirl", std::make_unique<BladeWhirl>(&warrior, monsters));[m
[32m+[m[32m    }[m
[32m+[m[32m    if (level == 3) {[m
[32m+[m[32m        skillManager.unlockSkill("BulkUp");[m
[32m+[m[32m        skillManager.addSkill("BulkUp", std::make_unique<BulkUp>(&warrior));[m
[32m+[m[32m    }[m
[32m+[m[32m    if (level == 4) {[m
[32m+[m[32m        skillManager.unlockSkill("Teleport");[m
[32m+[m[32m        skillManager.addSkill("Teleport", std::make_unique<Teleport>(&warrior, &mainTower));[m
[32m+[m[32m    }[m
[32m+[m[32m    upgradeManager.generateUpgradeOptions(); // ì—…ê·¸ë ˆì´ë“œ ì˜µì…˜ ìƒì„±[m
[32m+[m[32m    std::vector<std::string> options = upgradeManager.getUpgradeDescriptions();[m
[32m+[m[32m    upgradeUI.showOptions(options); // UIì— ì—…ê·¸ë ˆì´ë“œ ì˜µì…˜ í‘œì‹œ[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/Game.h b/Game.h[m
[1mindex 933ad44..07f4a0a 100644[m
[1m--- a/Game.h[m
[1m+++ b/Game.h[m
[36m@@ -11,6 +11,9 @@[m
 #include "MainTower.h"[m
 #include "UiManager.h"[m
 #include "WaveManager.h"[m
[32m+[m[32m#include "UpgradeManager.h"[m
[32m+[m[32m#include "UpgradeUI.h"[m
[32m+[m[32m#include "SkillManager.h"[m
 class Game {[m
 public:[m
     Game();[m
[36m@@ -20,7 +23,7 @@[m [mprivate:[m
     void handleEvents();[m
     void update();[m
     void render();[m
[31m-    void spawnMonster();[m
[32m+[m[32m    void onLevelUp();[m
 [m
     sf::RenderWindow window;[m
     Character warrior;[m
[36m@@ -36,12 +39,14 @@[m [mprivate:[m
     int level;[m
     float experience;[m
     float experienceToNextLevel;[m
[31m-[m
[32m+[m[32m    float deltaTime;[m
     sf::Font font;[m
     UIManager uiManager;[m
     MainTower mainTower;[m
     WaveManager waveManager;[m
[31m-[m
[32m+[m[32m    UpgradeManager upgradeManager;[m
[32m+[m[32m    UpgradeUI upgradeUI;[m
[32m+[m[32m    SkillManager skillManager;[m
 };[m
 [m
 #endif // GAME_H[m
[1mdiff --git a/Monster.cpp b/Monster.cpp[m
[1mindex b2d76a8..0f7ec96 100644[m
[1m--- a/Monster.cpp[m
[1m+++ b/Monster.cpp[m
[36m@@ -4,23 +4,21 @@[m
 #include "Character.h"[m
 #include "MainTower.h"[m
 #include <iostream>[m
[31m-[m
 // ìƒì„±ì[m
 Monster::Monster(float x, float y, float speed, MonsterType type)[m
[31m-    : movementSpeed(speed), damageTaken(0.0f), isTakingDamage(false), damageDisplayDuration(0.3f), damageDisplayTime(0.0f), attackPower(0), defense(0),skillDuration(5.0f),isSkillActive(false),isCloneActive(false)[m
[31m-,cloneDistance(50.0f),cloneRotationAngle(0.0f),cloneRotationSpeed(180.0f),attackRange(20.0f){[m
[32m+[m[32m    : movementSpeed(speed), damageTaken(0.0f), isTakingDamage(false), damageDisplayDuration(0.3f), damageDisplayTime(0.0f), attackPower(0), defense(0)[m
[32m+[m[32m    , attackRange(50), skillDuration(5.0f), isSkillActive(false), isCloneActive(false)[m
[32m+[m[32m    , cloneDistance(50.0f), cloneRotationAngle(0.0f), cloneRotationSpeed(180.0f)[m
[32m+[m[32m{[m
     shape.setSize(sf::Vector2f(30.0f, 30.0f));[m
     shape.setFillColor(sf::Color::Blue);[m
     shape.setPosition(x, y);[m
     shape.setOrigin(shape.getGlobalBounds().width / 2, shape.getGlobalBounds().height / 2); // ì›ì ì„ ì¤‘ì•™ìœ¼ë¡œ ì„¤ì •[m
     healthPoint = 100.0f;[m
[31m-[m
[31m-[m
     originalSpeed = speed;[m
     originalDefense = defense;[m
     originalAttackPower = attackPower;[m
     originalattackRange = attackRange;[m
[31m-[m
     switch (type) {[m
     case MonsterType::Speed:  //ì´ì† 3ë°°,ì²´ë ¥ 1/2ë°°[m
         texturePath = ("speedMonster.PNG");[m
[36m@@ -28,7 +26,7 @@[m [mMonster::Monster(float x, float y, float speed, MonsterType type)[m
         healthPoint = 50.0f;[m
         attackPower = 10.0f;[m
         defense = 10.0f;[m
[31m-        //shape.setFillColor(sf::Color::Cyan);[m
[32m+[m[32m        shape.setFillColor(sf::Color::Cyan);[m
         break;[m
     case MonsterType::Attack: //ê³µê²©ë ¥ 3ë°°[m
         texturePath = ("attackMonster.PNG");[m
[36m@@ -36,7 +34,7 @@[m [mMonster::Monster(float x, float y, float speed, MonsterType type)[m
         healthPoint = 100.0f;[m
         defense = 10.0f;[m
         attackPower = 30.0f; // ì¶”ê°€ ê³µê²©ë ¥[m
[31m-        //shape.setFillColor(sf::Color::Red);[m
[32m+[m[32m        shape.setFillColor(sf::Color::Red);[m
         break;[m
     case MonsterType::Defense: //ë°©ì–´ë ¥3ë°°,ì²´ë ¥2ë°°[m
         texturePath = ("defenseMonster.PNG");[m
[36m@@ -44,14 +42,14 @@[m [mMonster::Monster(float x, float y, float speed, MonsterType type)[m
         healthPoint = 200.0f;[m
         attackPower = 10.0f;[m
         defense = 30.0f; // ë°©ì–´ë ¥ ì¶”ê°€[m
[31m-        //shape.setFillColor(sf::Color::Magenta);[m
[32m+[m[32m        shape.setFillColor(sf::Color::Magenta);[m
         break;[m
     case MonsterType::Mid_Boss: // ë¯¸ë“œë³´ìŠ¤[m
         texturePath = "midboss.PNG";[m
         movementSpeed = 100.0f;[m
[31m-        healthPoint = 1000.0f;  [m
[31m-        attackPower = 50.0f;   [m
[31m-        defense = 20.0f;       [m
[32m+[m[32m        healthPoint = 1000.0f;[m
[32m+[m[32m        attackPower = 50.0f;[m
[32m+[m[32m        defense = 20.0f;[m
         skillDuration = 5.0f;[m
         //shape.setFillColor(sf::Color::Yellow);[m
         break;[m
[36m@@ -59,9 +57,9 @@[m [mMonster::Monster(float x, float y, float speed, MonsterType type)[m
     case MonsterType::Main_Boss: // ë©”ì¸ë³´ìŠ¤[m
         texturePath = "mainboss.PNG";[m
         movementSpeed = 80.0f;[m
[31m-        healthPoint = 5000.0f; [m
[31m-        attackPower = 100.0f;  [m
[31m-        defense = 50.0f;       [m
[32m+[m[32m        healthPoint = 5000.0f;[m
[32m+[m[32m        attackPower = 100.0f;[m
[32m+[m[32m        defense = 50.0f;[m
         skillDuration = 8.0f;[m
         //shape.setFillColor(sf::Color::Black);[m
         break;[m
[36m@@ -85,25 +83,10 @@[m [mMonster::Monster(float x, float y, float speed, MonsterType type)[m
         sprite.setTexture(texture);[m
         sprite.setScale(0.1f, 0.1f);[m
         sprite.setPosition(x, y);[m
[31m-        sprite.setOrigin(sprite.getGlobalBounds().width / 2, sprite.getGlobalBounds().height / 2);[m
[31m-    }[m
[31m-[m
[31m-    //repeat[m
[31m-    if (!texture.loadFromFile(texturePath)) {[m
[31m-        std::cerr << "Failed to load texture: " << texturePath << std::endl;[m
[31m-        shape.setFillColor(sf::Color::White);[m
[31m-    }[m
[31m-    else {[m
[31m-        texture.setRepeated(true);  // í…ìŠ¤ì²˜ ë°˜ë³µ ì„¤ì • ì¶”ê°€[m
[31m-        sprite.setTexture(texture);[m
[31m-        sprite.setScale(0.1f, 0.1f);[m
[31m-        sprite.setPosition(x, y);[m
[31m-        sprite.setOrigin(sprite.getGlobalBounds().width / 2, sprite.getGlobalBounds().height / 2);[m
[31m-        //ìˆ˜ì •ì½”ë“œ[m
[31m-        //sprite.setScale(3.0f, 3.0f);[m
[32m+[m[32m        //sprite.setOrigin(sprite.getGlobalBounds().width / 2, sprite.getGlobalBounds().height / 2);[m
[32m+[m[32m        sprite.setOrigin(500, 500);[m
     }[m
 }[m
[31m-[m
 void Monster::createClones() {[m
     if (!isCloneActive) {[m
         cloneSprites.clear();  // ê¸°ì¡´ ë¶„ì‹ ë“¤ ì œê±°[m
[36m@@ -145,7 +128,7 @@[m [mvoid Monster::removeClones() {[m
 }[m
 [m
 // update í•¨ìˆ˜ êµ¬í˜„[m
[31m-void Monster::update(const sf::Vector2f& heroinePosition, const sf::Vector2f& towerPosition, float deltaTime,Character& character,MainTower& mainTower) {[m
[32m+[m[32mvoid Monster::update(const sf::Vector2f& heroinePosition, const sf::Vector2f& towerPosition, float deltaTime, Character& character, MainTower& mainTower) {[m
     sf::Vector2f targetPosition;[m
     float distanceToHeroine = calculateDistance(sprite.getPosition(), heroinePosition);[m
     float distanceToTower = calculateDistance(sprite.getPosition(), towerPosition);[m
[36m@@ -162,22 +145,20 @@[m [mvoid Monster::update(const sf::Vector2f& heroinePosition, const sf::Vector2f& to[m
     sf::Vector2f direction = targetPosition - sprite.getPosition();[m
     float length = std::sqrt(direction.x * direction.x + direction.y * direction.y);[m
     // íŠ¹ì • ê±°ë¦¬ ì´ë‚´ë¡œ ì ‘ê·¼í–ˆì„ ë•Œ í”¼í•´ë¥¼ ì…í˜[m
[31m-    //float attackRange = 10.0f; // ê³µê²© ë²”ìœ„ (ê±°ë¦¬) (ì¡°ì •ê°€ëŠ¥)[m
[31m-[m
     if (length <= attackRange) {[m
         if (attackTimer.getElapsedTime().asSeconds() >= attackCooldown) {[m
             if (targetPosition == towerPosition) {[m
                 mainTower.takeDamage(attackPower);[m
[31m-                printf("Tower takeDamage!");[m
[32m+[m[32m                //printf("Tower takeDamage!");[m
             }[m
[31m-            else { [m
[32m+[m[32m            else {[m
                 character.takeDamage(attackPower);[m
[31m-                printf("character takeDamage!");[m
[32m+[m[32m                //printf("character takeDamage!");[m
             } // ìºë¦­í„°ì— í”¼í•´ ì…í˜[m
             attackTimer.restart(); // íƒ€ì´ë¨¸ ì´ˆê¸°í™”[m
         }[m
     }[m
[31m-    else if (length != 0) {[m
[32m+[m[32m    else if (length >= attackRange) {[m
         direction /= length; // ë°©í–¥ ì •ê·œí™”[m
         sprite.move(direction * movementSpeed * deltaTime); // ëª¬ìŠ¤í„° ì´ë™[m
     }[m
[36m@@ -188,7 +169,6 @@[m [mvoid Monster::update(const sf::Vector2f& heroinePosition, const sf::Vector2f& to[m
             damageTaken = 0.0f; // í”¼í•´ëŸ‰ ì´ˆê¸°í™”[m
         }[m
     }[m
[31m-[m
     // ë©”ì¸ ìŠ¤í‚¬ (15ì´ˆ ì¿¨íƒ€ì„)[m
     if (skillCooldown.getElapsedTime().asSeconds() >= 15.0f) {[m
         Fir_useSkill(character, mainTower);[m
[36m@@ -218,13 +198,11 @@[m [mvoid Monster::update(const sf::Vector2f& heroinePosition, const sf::Vector2f& to[m
 [m
 // draw í•¨ìˆ˜ êµ¬í˜„[m
 void Monster::draw(sf::RenderTarget& target)const {[m
[31m-[m
     if (isCloneActive) {[m
         for (const auto& cloneSprite : cloneSprites) {[m
             target.draw(cloneSprite);[m
         }[m
     }[m
[31m-[m
     target.draw(sprite);[m
 [m
     drawProjectiles(target); //íˆ¬ì‚¬ì²´ ê·¸ë¦¬ê¸°[m
[36m@@ -239,7 +217,7 @@[m [mvoid Monster::draw(sf::RenderTarget& target)const {[m
         damageText.setFillColor(sf::Color::White);[m
 [m
 [m
[31m-        damageText.setPosition(sprite.getPosition().x+30, sprite.getPosition().y - 30); // ìœ„ì¹˜ ì¡°ì •[m
[32m+[m[32m        damageText.setPosition(sprite.getPosition().x, sprite.getPosition().y - 70); // ìœ„ì¹˜ ì¡°ì •[m
 [m
         target.draw(damageText); // í”¼í•´ëŸ‰ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°[m
     }[m
[36m@@ -272,7 +250,6 @@[m [mfloat Monster::getHealthPoint()const {[m
     return healthPoint;[m
 }[m
 [m
[31m-[m
 //ì›ê±°ë¦¬ ê³µê²© ë¡œì§ ì¶”ê°€[m
 [m
 void Monster::shootProjectile(const sf::Vector2f& targetPos) {[m
[36m@@ -288,7 +265,7 @@[m [mvoid Monster::shootProjectile(const sf::Vector2f& targetPos) {[m
 void Monster::updateProjectiles(float deltaTime, Character& character, MainTower& mainTower) {[m
     for (auto& projectile : projectiles) {[m
         if (!projectile.active) continue;[m
[31m-        [m
[32m+[m
         // íˆ¬ì‚¬ì²´ ì´ë™[m
         projectile.shape.move(projectile.velocity * deltaTime);[m
 [m
[36m@@ -353,7 +330,6 @@[m [mvoid Monster::Fir_useSkill(Character& character, MainTower& mainTower) {[m
         attackRange = originalattackRange * 2.0f;[m
 [m
         createClones();[m
[31m-[m
         //ê´‘ì—­ ê³µê²©[m
         float attackRadius = 200.0f;[m
         if (calculateDistance(sprite.getPosition(), character.getPosition()) <= attackRadius) {[m
[36m@@ -395,7 +371,6 @@[m [mvoid Monster::Sec_useSkill(Character& character, MainTower& mainTower) {[m
         else {[m
             targetPos = mainTower.getPosition();[m
         }[m
[31m-[m
         sf::Vector2f baseDirection = targetPos - sprite.getPosition();[m
         float baseLength = std::sqrt(baseDirection.x * baseDirection.x + baseDirection.y * baseDirection.y);[m
         if (baseLength != 0) {[m
[1mdiff --git a/Monster.h b/Monster.h[m
[1mindex 5eea804..2ecff64 100644[m
[1m--- a/Monster.h[m
[1m+++ b/Monster.h[m
[36m@@ -15,20 +15,26 @@[m [menum class MonsterType {[m
 };[m
 class Monster {[m
 public:[m
[32m+[m[32m    // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½[m
     Monster(float x, float y, float speed, MonsterType type);[m
 [m
[31m-    void update(const sf::Vector2f& CharacterPos,const sf::Vector2f& MainTowerPos, float deltaTime,Character& character,MainTower& mainTower);[m
[32m+[m[32m    // ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Æ® ï¿½Ô¼ï¿½ (ï¿½ï¿½Ç¥ ï¿½ï¿½Ä¡ï¿½ï¿½ ï¿½Ìµï¿½)[m
[32m+[m[32m    void update(const sf::Vector2f& CharacterPos, const sf::Vector2f& MainTowerPos, float deltaTime, Character& character, MainTower& mainTower);[m
 [m
[32m+[m[32m    // ï¿½ï¿½ï¿½Í¸ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ì¿¡ ï¿½×¸ï¿½ï¿½ï¿½ ï¿½Ô¼ï¿½[m
     void draw(sf::RenderTarget& target)const;[m
 [m
[32m+[m[32m    // ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½Ä¡ ï¿½ï¿½È¯ ï¿½Ô¼ï¿½[m
     sf::Vector2f getPosition();[m
 [m
[32m+[m[32m    // Æ¯ï¿½ï¿½ ï¿½ï¿½Ä¡ ï¿½ï¿½Ã³ï¿½ï¿½ ï¿½Ö´ï¿½ï¿½ï¿½ È®ï¿½ï¿½ï¿½Ï´ï¿½ ï¿½Ô¼ï¿½ (ï¿½Ì´Ï¸ï¿½ È°ï¿½ï¿½ ï¿½ï¿½)[m
     bool isNear(sf::Vector2f position, float radius) const;[m
 [m
 [m
     void takeDamage(float attackDamage);[m
     float getHealthPoint()const;[m
 [m
[32m+[m
     void Fir_useSkill(Character& character, MainTower& mainTower);[m
     void Sec_useSkill(Character& character, MainTower& mainTower);[m
 [m
[36m@@ -52,14 +58,13 @@[m [mprivate:[m
     float attackPower; //ê³µê²©ë ¥[m
     float defense;  //ë°©ì–´ë ¥[m
     float attackRange;[m
[31m-[m
     sf::Clock attackTimer; // ê³µê²© íƒ€ì´ë¨¸ ì¶”ê°€[m
     float attackCooldown = 1.0f; // 1ì´ˆ ì£¼ê¸°[m
 [m
     std::string texturePath;[m
     sf::Texture texture;[m
     sf::Sprite sprite;[m
[31m-    [m
[32m+[m
     //mid,main boss skill variable[m
     sf::Clock skillCooldown;[m
     sf::Clock rangedAttackCooldown;[m
[1mdiff --git a/SkillManager.cpp b/SkillManager.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..1a4fe5b[m
[1m--- /dev/null[m
[1m+++ b/SkillManager.cpp[m
[36m@@ -0,0 +1,55 @@[m
[32m+[m[32m#include "SkillManager.h"[m
[32m+[m
[32m+[m[32mSkillManager::SkillManager() {[m
[32m+[m[32m    // ì´ˆê¸° ìƒíƒœ: ëª¨ë“  ìŠ¤í‚¬ ì ê¸ˆ[m
[32m+[m[32m    skillStates["BladeWhirl"] = false;[m
[32m+[m[32m    skillStates["BulkUp"] = false;[m
[32m+[m[32m    skillStates["Teleport"] = false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid SkillManager::addSkill(const std::string& name, std::unique_ptr<BaseSkill> skill) {